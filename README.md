# FitAI Telegram Bot with GigaChat

**FitAI** — это асинхронный Telegram-бот, который помогает пользователям достичь спортивных целей.  
Он умеет:
- Принимать и хранить **регистрационные данные** (имя, возраст, вес, рост и т.д.)  
- Генерировать **рацион питания** и **программу тренировок** на базе [GigaChat](https://github.com/langchain-ai/langchain) (через LangChain Community)  
- Сохранять и просматривать **историю диалогов** в базе данных (PostgreSQL через SQLAlchemy)  
- **Планировать уведомления** на будущее время с помощью [APScheduler](https://apscheduler.readthedocs.io/en/stable/), а также отправлять пользователю напоминания через бот.  
- Отслеживать **неактивность** пользователя (7 дней) и автоматически мотивировать его вновь заняться спортом.

## Структура проекта

```
.
├── config.py             # Параметры Telegram Bot и PostgreSQL
├── db.py                 # SQLAlchemy-модели (User, MessageLog, Notification)
├── fit_ai.py             # Основной класс FitAI (работа с GigaChat и function calling)
├── function_calling/     # Вызов "функций" (create_notification, update, delete...)
│   ├── __init__.py
│   └── manager.py
├── handlers/             # Роутеры Aiogram (регистрация, меню)
│   ├── __init__.py
│   ├── menu.py
│   └── registration.py
├── init_bot.py           # Инициализация Aiogram Bot & Dispatcher
├── main.py               # Точка входа (старт бота, schedule_existing_notifications)
├── notifications/        # Логика работы с APScheduler и уведомлениями
│   ├── __init__.py
│   └── manager.py
├── readme.md
└── requirements.txt
```

## Подготовка и запуск

1. **Установите PostgreSQL** и создайте базу/пользователя:
   ```sql
   CREATE USER bot_user WITH PASSWORD 'bot_pass';
   CREATE DATABASE bot_db OWNER bot_user;
   ```
   Убедитесь, что в `config.py` указаны верные настройки:
   ```python
   POSTGRES_DB = "bot_db"
   POSTGRES_USER = "bot_user"
   POSTGRES_PASSWORD = "bot_pass"
   POSTGRES_HOST = "localhost"
   POSTGRES_PORT = 5432
   ```

2. Укажите ваш **Telegram Bot Token** в `config.py`:
   ```python
   TELEGRAM_BOT_TOKEN = "1234567:ABCDEFG..."
   ```
3. **Установите зависимости** (например, через pip):
   ```bash
   pip install -r requirements.txt
   ```
4. **Запустите**:
   ```bash
   python main.py
   ```
5. Найдите бота в Telegram и нажмите **Start**.

## Проверка уведомлений

1. После регистрации попробуйте вызвать функцию GigaChat либо вручную: `/chat Хочу создать уведомление на 2025-01-18T14:00:00+03:00` (пример).  
2. Модель может ответить JSON, например:

   ```json
   {
     "name": "create_notification",
     "parameters": {
       "user_id": "1",
       "message": "Пора на тренировку!",
       "time": "2025-01-18T14:00:00+03:00"
     }
   }
   ```
3. После этого бот подтвердит, что функция выполнена. Зайдите в базу (таблица `notifications`) и убедитесь, что запись создалась.  
4. Дождитесь указанного времени — бот отправит уведомление в личку.  

Аналогично для update, delete, list_notifications.  

## Блок-схема работы

Ниже приведена примерная блок-схема (упрощённо) с основными этапами работы бота — от **регистрации** пользователя до отправки уведомлений (включая неактуальные данные и ошибки).

```mermaid
flowchart TB
    A0[Пользователь заходит в чат] --> A1[/start]
    A1 -->|вызывает registration.py| A2(Вопросы по анкете)
    A2 -->|вводит данные| A3{Валидация}
    A3 -->|корректно| A4(Сохранение анкеты в БД)
    A3 -->|ошибка ввода| A2

    A4 --> A5[/menu] 
    A5 --> B1(Пользователь вызывает команду: /meal_plan, /workout_plan или /chat)
    B1 -->|вопрос| B2(FitAI.chat())

    B2 -->|LangChain диалог| B3{Нужна ли функция?}
    B3 -->|нет| B4(Отправка ответа пользователю)
    B3 -->|да| B5(Генерирует JSON: create / list / update / delete)
    
    B5 --> B6(function_calling.manager)
    B6 --> B7(notifications.manager) 
    
    B7 -->|create_notification ...| B8(Сохранение уведомления в БД)
    B8 --> B9(Добавление job в Apscheduler)
    B9 --> B10(Подтверждение "Функция выполнена")
    B10 -->|ответ "Функция выполнена"| B2

    B4 -->|конец ответа| B11[/chat idle.../]

    B11 -->|время идёт| C1{7 дней inactivity?}
    C1 -->|нет| B11
    C1 -->|да| C2(handle_inactivity job)
    C2 -->|запускается FitAI| C3("Замотивируй меня ...")
    C3 -->|ответ| C4(Отправка сообщения пользователю)

    subgraph Примечания
    end
```

1. **Регистрация**: бот спрашивает имя, возраст, пол и т.д. При некорректном вводе — повторяет запрос. При успехе — сохраняет в базу.  
2. **Меню**: пользователь вызывает команды `/menu`, `/meal_plan`, `/workout_plan`, `/chat ...`.  
3. **Диалог с моделью**: используется класс `FitAI`, который хранит историю сообщений в `messages`. Если в ответе GigaChat есть JSON-функция (например, `{"name":"create_notification", "parameters":{...}}`), вызывается соответствующая функция из пакета `function_calling`.  
4. **Уведомления**: при создании уведомления оно сохраняется в таблицу `notifications` и регистрируется в планировщике Apscheduler. Когда наступает `time_utc`, Apscheduler вызывает `_notify_user(...)`.  
5. **Неактивность**: каждый раз при сообщении пользователя таймер «7 дней неактивности» перезапускается. По истечении 7 дней вызывается `handle_inactivity(...)`, которая генерирует для пользователя новую мотивацию.  

Так бот обрабатывает все запросы и уведомления, учитывая локальное время пользователя (перевод в UTC при сохранении).  

---  

**Вот и всё!** При желании можно добавить **Middleware** для проверки «зарегистрирован ли пользователь» перед выполнением команд, хранить **job_id** в БД (чтобы можно было отменять/перезаписывать задачи), делать более гибкие часовые пояса и т.д. Но в представленной конфигурации уже будет работать:
- Регистрация и хранение данных в PostgreSQL  
- Сохранение истории диалога (для LangChain)  
- Запланированные уведомления (Apscheduler) + восстановление их при рестарте бота.  
- 7-дневная проверка неактивности.  

Удачи в развитии проекта!